#region License notice

/*
  This file is part of the Ceres project at https://github.com/dje-dev/ceres.
  Copyright (C) 2020- by David Elliott and the Ceres Authors.

  Ceres is free software under the terms of the GNU General Public License v3.0.
  You should have received a copy of the GNU General Public License
  along with Ceres. If not, see <http://www.gnu.org/licenses/>.
*/

#endregion

#region Using directives
// TODO: restore this class

using System;
using System.Collections.Generic;
using System.IO;
using System.IO.Compression;

using System.Runtime.InteropServices;
using System.Threading;

using SharpCompress.Common;
using SharpCompress.Readers;
using SharpCompress.Readers.Tar;

using Zstandard.Net;

using Ceres.Base.Misc;

#endregion

namespace Ceres.Chess.EncodedPositions
{
  /// <summary>
  /// Static internal helper class for enumerating all the chunks (games)
  /// contained in a Leela Chess Zero raw training file (packed with TAR).
  /// 
  /// Two formats are supported:
  ///   - the original files downloaded from LC0 training site, which are in EncodedTrainingPosition format
  ///   - files compressed with ZStandard, which are in EncodedTrainingPositionCompressed format
  ///     (these files are generated by Ceres utility EncodedTrainingPositionTrainingRewriter.cs).
  /// </summary>
  public static class EncodedTrainingPositionReader
  {
    public const int MAX_POSITIONS_PER_STREAM = 100 * 300; // assume 100 games, worst case 300 ply on average

    static long totalBytesRead;


    /// <summary>
    /// Sequential enumerator for all positions within specified TAR file (matching optional filter).
    /// </summary>
    /// <param name="trainingTARFileName"></param>
    /// <param name="processFilePredicate"></param>
    /// <param name="filterOutFRCGames"></param>
    /// <returns></returns>
    public static IEnumerable<EncodedTrainingPosition> EnumerateTrainingPositions(string trainingTARFileName,
                                                                                  Predicate<string> processFilePredicate = null,
                                                                                  bool filterOutFRCGames = true)
    {
      foreach (EncodedTrainingPositionGame game in EnumerateGames(trainingTARFileName, processFilePredicate, filterOutFRCGames))
      {
        for (int i = 0; i < game.NumPositions; i++)
        {
          yield return game.TrainingPosition(i);
        }
      }
    }


    /// <summary>
    /// Sequential enumerator for all positions within specified TAR file (matching optional filter).
    /// </summary>
    /// <param name="trainingTARFileName"></param>
    /// <param name="processFilePredicate"></param>
    /// <param name="filterOutFRCGames"></param>
    /// <returns></returns>
    public static IEnumerable<EncodedPositionWithHistory> EnumeratePositions(string trainingTARFileName,
                                                                             Predicate<string> processFilePredicate = null,
                                                                             bool filterOutFRCGames = true)
    {
      foreach (EncodedTrainingPositionGame game in EnumerateGames(trainingTARFileName, processFilePredicate, filterOutFRCGames))
      {
        for (int i=0;i<game.NumPositions;i++)
        {
          yield return game.PositionAtIndex(i);
        }
      } 
    }


    /// <summary>
    /// Sequential enumerator for all games within specified TAR file (matching optional filter).
    /// </summary>
    /// <param name="trainingTARFileName"></param>
    /// <param name="processFilePredicate"></param>
    /// <param name="filterOutFRCGames"></param>
    /// <returns></returns>
    /// <exception cref="Exception"></exception>
    public static IEnumerable<EncodedTrainingPositionGame> EnumerateGames(string trainingTARFileName,
                                                                          Predicate<string> processFilePredicate = null,
                                                                          bool filterOutFRCGames = true)
    {
      EncodedTrainingPosition[] positionsBuffer = new EncodedTrainingPosition[MAX_POSITIONS_PER_STREAM];
      EncodedTrainingPositionCompressed[] positionsBufferCompressed = new EncodedTrainingPositionCompressed[MAX_POSITIONS_PER_STREAM];
      byte[] streamByteBuffer = new byte[Marshal.SizeOf<EncodedTrainingPositionCompressed>() * MAX_POSITIONS_PER_STREAM];

      if (!trainingTARFileName.ToUpper().EndsWith("TAR"))
      {
        throw new Exception("expected TAR");
      }

      using (Stream stream = File.OpenRead(trainingTARFileName))
      {
        IReader reader = TarReader.Open(stream);
        while (reader.MoveToNextEntry())
        {
          if (reader.Entry.IsDirectory)
          {
            continue;
          }

          // Skip if this file does not match our filter.
          if (processFilePredicate != null && !processFilePredicate(reader.Entry.Key.ToUpper()))
          {
            continue;
          }

          string fileName = reader.Entry.Key.ToLower();
          if (fileName.EndsWith("gz") || fileName.EndsWith("zst"))
          {
            // We assume that any files compressed with ZStandard (ZST) are also compressed as EncodedTrainingPositionCompressed
            // so we need to first decompress using ZStandard, then convert the format of the positions
            // to the full EncodedTrainingPosition (uncompressed) structures.
            bool areCompressedPositions = fileName.EndsWith("zst");

            using (EntryStream es = reader.OpenEntryStream())
            {
              // Process all files within
              bool isZST = fileName.ToUpper().EndsWith(".ZST");
              bool isGZ = fileName.ToUpper().EndsWith(".GZ");
              bool isPackedGames = isZST; // assume ZST are packed
                                          // TODO: remove this sentinel positionsBuffer[0].PositionWithBoards.MiscInfo.InfoTraining.Unused1 == EncodedTrainingPositionCompressedConverter.SENTINEL_MARK_FIRST_MOVE_IN_GAME_IN_UNUSED1;

              if (!isZST && !isGZ)
              {
                throw new Exception("TAR entry name was expected to be a ZST or GZ file, saw instead " + fileName);
              }

              Stream decompressionStream = isGZ ? new GZipStream(es, CompressionMode.Decompress)
                                                : new ZstandardStream(es, CompressionMode.Decompress);
              using (decompressionStream)
              {
                if (!isPackedGames)
                {
                  // Uncompressed read
                  int numRead = ReadFromStream(decompressionStream, streamByteBuffer, ref positionsBuffer);

                  if (numRead == 0)
                  {
                    throw new Exception("Stream contained no data, expected EncodedTrainingPosition");
                  }

                  // Single game, not packed with multiple.
                  EncodedTrainingPositionGameDirect ret = new (positionsBuffer.AsMemory(0, numRead));
                  if (!filterOutFRCGames || !ret.IsFRCGame)
                  {
                    yield return ret;
                  }
                }
                else
                {
                  int numRead = ReadFromStreamCompressed(decompressionStream, streamByteBuffer, ref positionsBufferCompressed);

                  if (numRead == 0)
                  {
                    throw new Exception("Stream contained no data, expected EncodedTrainingPosition");
                  }

                  // Set of packed games.
                  int curIndex = 0;
                  while (curIndex < numRead)
                  {
                    // Find the start of the next game to know how long this game is.
                    int nextStartIndex = curIndex + 1;
                    while (nextStartIndex < numRead
                        && positionsBufferCompressed[nextStartIndex].PositionWithBoards.MiscInfo.InfoTraining.Unused2 != EncodedTrainingPositionCompressedConverter.SENTINEL_MARK_FIRST_MOVE_IN_GAME_IN_UNUSED1)
                    {
                      nextStartIndex++;
                    }

                    int lengthThisGame = nextStartIndex - curIndex;
                    if (lengthThisGame == 0)
                    {
                      throw new Exception("Unexpected zero length game");
                    }

                    Memory<EncodedTrainingPositionCompressed> gamePositions = new Memory<EncodedTrainingPositionCompressed>(positionsBufferCompressed, curIndex, lengthThisGame);
                    EncodedTrainingPositionGameCompressed ret = new EncodedTrainingPositionGameCompressed(gamePositions);

                    if (!filterOutFRCGames || !ret.IsFRCGame)
                    {
                      gamePositions.Span[0].PositionWithBoards.MiscInfo.InfoTraining.SetUnused2(0); // reset the sentinel
                      yield return ret;

                    }
                    curIndex = nextStartIndex;
                  }
                }
              }
            }
          }
        }
      }
    }


    static unsafe int ReadFromStream(Stream stream, byte[] rawBuffer, ref EncodedTrainingPosition[] buffer)
    {
      int bytesRead = 0;

      // Read decompressed bytes.
      int thisBytes = 0;
      do
      {
        thisBytes = stream.Read(rawBuffer, bytesRead, rawBuffer.Length - bytesRead);
        bytesRead += thisBytes;
      } while (thisBytes > 0);


      Interlocked.Add(ref totalBytesRead, bytesRead);

      return ObjUtils.CopyBytesIntoStructArray(rawBuffer, buffer, bytesRead);
    }

    static unsafe int ReadFromStreamCompressed(Stream stream, byte[] rawBuffer, ref EncodedTrainingPositionCompressed[] buffer)
    {
      int bytesRead = 0;

      // Read decompressed bytes.
      int thisBytes = 0;
      do
      {
        thisBytes = stream.Read(rawBuffer, bytesRead, rawBuffer.Length - bytesRead);
        bytesRead += thisBytes;
      } while (thisBytes > 0);


      Interlocked.Add(ref totalBytesRead, bytesRead);

      int numItems = bytesRead / Marshal.SizeOf(typeof(EncodedTrainingPositionCompressed));
      ObjUtils.CopyBytesIntoStructArray(rawBuffer, buffer, bytesRead);
      return numItems;
    }

  }
}
